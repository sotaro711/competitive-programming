

# for i in range(N):
#     for j in range(N):
#         for k in range(N):
#             if A[i] + A[j] + A[k] == S:
#                 print("Yes")

# 1 << N = 2**N

# 動的計画法
N, S = map(int, input().split())
A = list(map(int, input().split()))

# 二次元配列作成
# i = 0
dp = [[None] * (S+1) for i in range(N+1)]
# print(dp)
dp[0][0] = True
for i in range(1, S+1):
    dp[0][i] = False
# print(dp)

for i in range(1, N+1):
    for j in range(0, S+1):
        # 作りたいカードjがカードA[i]より小さい時
        if j < A[i-1]:
            # カードi-1の時点で合計がA[j]であり、iを選ばない
            if dp[i-1][j] == True:
                dp[i][j] = True
            else:
                dp[i][j] = False

        # 作りたいカードがA[i-1]よりも大きい時、
        if j >= A[i-1]:
            # 前の行で、dp[i-1][j-A[i-1]]がTrueだったら、A[i]を足すことで次の行がTrueになるよね
            # 例：dp[2][4] = True, A[3] = 3より、dp[3-1][7-A[3-1]] == True
            if dp[i-1][j] == True or dp[i-1][j-A[i-1]] == True:
                dp[i][j] = True
            else:
                dp[i][j] = False

# 最終的にN枚のカードを使ってSを作れていれば良い
if dp[N][S] == True:
    print("Yes")
else:
    print("No")

